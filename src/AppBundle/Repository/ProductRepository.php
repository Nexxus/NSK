<?php

/*
 * Nexxus Stock Keeping (online voorraad beheer software)
 * Copyright (C) 2018 Copiatek Scan & Computer Solution BV
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see licenses.
 *
 * Copiatek – info@copiatek.nl – Postbus 547 2501 CM Den Haag
 */

namespace AppBundle\Repository;

use AppBundle\Entity\AOrder;
use AppBundle\Entity\Product;
use AppBundle\Entity\ProductStatus;
use AppBundle\Entity\User;
use AppBundle\Entity\PurchaseOrder;
use AppBundle\Entity\SalesOrder;
use AppBundle\Entity\TaskService;
use AppBundle\Entity\ProductAttributeRelation;
use AppBundle\Entity\ProductOrderRelation;

/**
 * ProductRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductRepository extends \Doctrine\ORM\EntityRepository
{
    public function findAll()
    {
        return $this->findBy(array(), array('id' => 'DESC'));
    }

    public function findMine(User $user)
    {
        if ($user->hasRole("ROLE_LOCAL") || $user->hasRole("ROLE_LOGISTICS"))
            return $this->findBy(array("location" => $user->getLocationIds()), array('id' => 'DESC'));
        else
            return $this->findBy(array(), array('id' => 'DESC'));
    }

    /**
     * This function searches in fields: Id, Sku, Name
     */
    public function findBySearchQuery(\AppBundle\Helper\IndexSearchContainer $search)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->from("AppBundle:Product", "o")->select("o")->orderBy("o.id", "DESC");

        if ($search->user->hasRole("ROLE_LOCAL") || $search->user->hasRole("ROLE_LOGISTICS"))
            $qb = $qb->where('IDENTITY(o.location) IN (:locationIds)')->setParameter('locationIds', $search->user->getLocationIds()); 

        if ($search->query)
        {
            if (is_numeric($search->query))
            {
                $qb = $qb->andWhere("o.id = :query OR o.sku = :query")->setParameter("query", $search->query);
            }
            else
            {
                $qb = $qb->andWhere("o.name LIKE :queryLike OR o.sku = :query")->setParameter("query", $search->query)->setParameter("queryLike", '%'.$search->query.'%');
            }
        }

        if ($search->location)
            $qb = $qb->andWhere("o.location = :location")->setParameter("location", $search->location);
        elseif ($search->user->hasRole("ROLE_LOCAL") || $search->user->hasRole("ROLE_LOGISTICS"))
            $qb = $qb->andWhere('IDENTITY(o.location) IN (:locationIds)')->setParameter('locationIds', $search->user->getLocationIds()); 

        if ($search->status)
            $qb = $qb->andWhere("o.status = :status")->setParameter("status", $search->status);

        if ($search->producttype)
            $qb = $qb->andWhere("o.type = :producttype")->setParameter("producttype", $search->producttype);

        $products = $qb->getQuery()->getResult();

        if ($search->availability && count($products) > 0)
        {
            $quantityMethod = 'getQuantity' . $search->availability;
            $products = array_filter($products, function (Product $product) use ($quantityMethod) {
                return $product->{$quantityMethod}() > 0;
            });
        }

        return $products;
    }

    /**
     * This function searches in fields: Sku (of products) and orderNr (of orders)
     */
    public function findByBarcodeSearchQuery(\AppBundle\Helper\IndexSearchContainer $search)
    {
        $result = array();

        foreach ($this->findBySearchQuery($search) as $product)
        {
            /** @var Product $product */
            $result["product-".$product->getId()] = sprintf("Product '%s' with SKU %s, in quantity %s, at location %s",
                $product->getName(), $product->getSku(), $product->getQuantityInStock(true), $product->getLocation()->getName());
        }

        foreach ($this->_em->getRepository(SalesOrder::class)->findBySearchQuery($search) as $salesOrder)
        {
            /** @var SalesOrder $salesOrder */
            $result["salesorder-".$salesOrder->getId()] = sprintf("Sales order with nr %s, dated %s, to customer %s",
                $salesOrder->getOrderNr(), $salesOrder->getOrderDate()->format("M j, Y"), $salesOrder->getCustomer()->getName());
        }

        foreach ($this->_em->getRepository(PurchaseOrder::class)->findBySearchQuery($search) as $purchaseOrder)
        {
            /** @var PurchaseOrder $purchaseOrder */
            $result["purchaseorder-".$purchaseOrder->getId()] = sprintf("Purchase order with nr %s, dated %s, from supplier %s",
                $purchaseOrder->getOrderNr(), $purchaseOrder->getOrderDate()->format("M j, Y"), $purchaseOrder->getSupplier()->getName());
        }

        return $result;
    }

    public function findStock(User $user)
    {
        $products = $this->findMine($user);

        $products = array_filter($products,
            function(Product $product) {
                return $product->getQuantityInStock() != 0;
            });

        return $products;
    }

    public function findStockAndNotYetInOrder(User $user, SalesOrder $order)
    {
        $products = $this->findStock($user);

        // cannot add product to sales order twice
        $products = array_filter($products,
            function (Product $product) use ($order) {
                /** @var SalesOrder $order */
                foreach ($order->getProductRelations() as $r)
                {
                    if ($r->getProduct() == $product)
                        return false;
                }
                return true;
            });

        return $products;
    }

    public function findLastUpdated(User $user) {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->from("AppBundle:Product", "o")
            ->select("o")
            ->orderBy("o.updatedAt", "DESC")
            ->setMaxResults(5);

        if ($user->hasRole("ROLE_LOCAL") || $user->hasRole("ROLE_LOGISTICS"))
            $qb = $qb->andWhere('IDENTITY(o.location) IN (:locationIds)')->setParameter('locationIds', $user->getLocationIds()); 

        return $qb->getQuery()->getResult();
    }

    public function generateProductAttributeRelations(Product $product)
    {
        if (!$product->getType())
            return;

        // get all possible attributes for this product type
        $allAttributes = $product->getType()->getAttributes();

        // add new attributes to this product
        foreach ($allAttributes as $newAttribute)
        {
            $exists = $product->getAttributeRelations()->exists(function($key, $r) use ($newAttribute) {
                /** @var ProductAttributeRelation $r */
                return $r->getAttribute() == $newAttribute;
            });

            if (!$exists)
            {
                $r = new ProductAttributeRelation($product, $newAttribute);
                $this->_em->persist($r);
            }
        }
    }

    public function generateProductOrderRelation(Product $product, AOrder $order, $quantity = 1)
    {
        $exists = $product->getOrderRelations()->exists(function($key, $r) use ($order) {
            /** @var ProductOrderRelation $r */
            return $r->getOrder() == $order;
        });

        if (!$exists)
        {
            $r = new ProductOrderRelation($product, $order);
            $r->setQuantity($quantity);
            $this->_em->persist($r);
            return $r;
        }

        return null;
    }

    public function generateTaskServices(ProductOrderRelation $productOrderRelation)
    {
        if (!$productOrderRelation->getProduct() || !$productOrderRelation->getProduct()->getType())
            return;

        $order = $productOrderRelation->getOrder();
        $orderClass = get_class($order);

        if (!$order || $orderClass != PurchaseOrder::class)
            throw new \Exception("Tasks can only be added to purchase order.");

        // get all possible tasks for this product type
        $allTasks = $productOrderRelation->getProduct()->getType()->getTasks();

        // add new tasks to this product relation
        foreach ($allTasks as $newTask)
        {
            $exists = $productOrderRelation->getServices()->exists(function($key, TaskService $s) use ($newTask) {
                return $s->getTask() == $newTask;
            });

            if (!$exists)
            {
                $s = new TaskService($newTask, $productOrderRelation);
                $this->_em->persist($s);
            }
        }
    }

    /**
     * Separates a quantity of products from an existing Product object bundle
     * @param Product $product
     * @param ProductStatus $status
     * @param int $quantity
     * @param bool $individualize
     * @param bool $salesorder
     * @param bool $newSku
     */
    public function splitProduct(Product $product, ProductStatus $status, $quantity, $individualize, $sales, $newSku)
    {
        if ($sales)
        {
            $i = 1;
            foreach ($product->getOrderRelations() as $orderRelation)
            {
                /** @var ProductOrderRelation $orderRelation */
                if (is_a($orderRelation->getOrder(), SalesOrder::class))
                {
                    for ($ii = 1; $ii <= $orderRelation->getQuantity(); $ii++)
                    {
                        $newSkuIndex = $newSku ? $i-1 : false;
                        $this->splitToProduct($product, $status, 1, "(split ".$i.")", $newSkuIndex, $orderRelation);
                        $i++;
                    }
                }
            }

            for ($ii = $i; $ii <= $quantity; $ii++)
            {
                $newSkuIndex = $newSku ? $ii-1 : false;
                $this->splitToProduct($product, $status, 1, "(split ".$ii.")", $newSkuIndex);
            }
        }
        elseif ($individualize && $quantity > 1)
        {
            for ($i = 1; $i <= $quantity; $i++)
            {
                $newSkuIndex = $newSku ? $i-1 : false;
                $this->splitToProduct($product, $status, 1, "(split ".$i.")", $newSkuIndex);
            }
        }
        else
        {
            $newSkuIndex = $newSku ? 0 : false;
            $this->splitToProduct($product, $status, $quantity, "(split)", $newSkuIndex);
        }
    }

    /**
     * Separates a quantity of products from an existing Product object bundle
     * @param Product $product
     * @param ProductStatus $status
     * @param int $quantity
     * @param string $nameSupplement
     * @param int $newSkuIndex One or higher if new SKU is needed
     * @param ProductOrderRelation $salesRelation
     * @return Product The new product
     */
    private function splitToProduct(Product $product, ProductStatus $status, $quantity, $nameSupplement, $newSkuIndex, $salesRelation = null)
    {
        $newProduct = new Product();
        
        if ($quantity > 1 && $salesRelation)
        {
            throw new \Exception("Bundle split with sales order involved is not allowed");
        }
        elseif ($salesRelation)
        {
            $newSalesRelation = new ProductOrderRelation($newProduct, $salesRelation->getOrder());
            $newSalesRelation->setQuantity(1);
            $newSalesRelation->setPrice($salesRelation->getPrice());
            $this->_em->persist($newSalesRelation);
        }
        
        if ($product->getDescription()) $newProduct->setDescription($product->getDescription());
        if ($product->getLocation()) $newProduct->setLocation($product->getLocation());
        $newProduct->setName($product->getName() . " " . trim($nameSupplement));
        if ($product->getOwner()) $newProduct->setOwner($product->getOwner());
        if ($product->getPrice() !== null) $newProduct->setPrice($product->getPrice());
        $newProduct->setStatus($status);
        if ($product->getType()) $newProduct->setType($product->getType());
        if ($newSkuIndex !== false) 
            $newProduct->setSku(time() + $newSkuIndex);
        else
            $newProduct->setSku($product->getSku());

        $this->_em->persist($newProduct);

        $purchaseRelation = $product->getPurchaseOrderRelation();
        $newPurchaseRelation = new ProductOrderRelation($newProduct, $purchaseRelation->getOrder());
        $newPurchaseRelation->setQuantity($quantity);
        if ($purchaseRelation->getPrice()) $newPurchaseRelation->setPrice($purchaseRelation->getPrice());
        $this->_em->persist($newPurchaseRelation);

        foreach ($product->getAttributeRelations() as $attributeRelation)
        {
            $newAttributeRelation = new ProductAttributeRelation($newProduct, $attributeRelation->getAttribute());
            if ($attributeRelation->getValueProduct()) $newAttributeRelation->setQuantity(0);
            if ($attributeRelation->getValue()) $newAttributeRelation->setValue($attributeRelation->getValue());
            if ($attributeRelation->getValueProduct()) $newAttributeRelation->setValueProduct($attributeRelation->getValueProduct());
            $this->_em->persist($newAttributeRelation);
        }

        $purchaseRelation->setQuantity($purchaseRelation->getQuantity() - $quantity);
        if ($salesRelation) $salesRelation->setQuantity($salesRelation->getQuantity() - $quantity);

        return $newProduct;
    }
}
