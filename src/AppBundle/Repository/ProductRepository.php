<?php

/*
 * Nexxus Stock Keeping (online voorraad beheer software)
 * Copyright (C) 2018 Copiatek Scan & Computer Solution BV
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see licenses.
 *
 * Copiatek – info@copiatek.nl – Postbus 547 2501 CM Den Haag
 */

namespace AppBundle\Repository;

use AppBundle\Entity\AOrder;
use AppBundle\Entity\Product;
use AppBundle\Entity\User;
use AppBundle\Entity\SalesOrder;
use AppBundle\Entity\ProductAttributeRelation;
use AppBundle\Entity\ProductOrderRelation;
use Doctrine\Common\Collections\ArrayCollection;

/**
 * ProductRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductRepository extends \Doctrine\ORM\EntityRepository
{
    public function findAll()
    {
        return $this->findBy(array(), array('id' => 'DESC'));
    }

    public function findMine(User $user)
    {
        if ($user->hasRole("ROLE_LOCAL"))
            return $this->findBy(array("location" => $user->getLocation()), array('id' => 'DESC'));
        else
            return $this->findBy(array(), array('id' => 'DESC'));
    }

    /**
     * This function searches in fields: Id, Sku, Name
     */
    public function findBySearchQuery(\AppBundle\Helper\IndexSearchContainer $search)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->from("AppBundle:Product", "o")->select("o")->orderBy("o.id", "DESC");

        if ($search->query)
        {
            if (is_numeric($search->query))
            {
                $qb = $qb->andWhere("o.id = :query OR o.sku = :query");
            }
            else
            {
                $qb = $qb->andWhere("o.name LIKE :queryLike OR o.sku = :query")->setParameter("queryLike", '%'.$search->query.'%');
            }

            $qb = $qb->setParameter("query", $search->query);
        }

        if ($search->location)
            $qb = $qb->andWhere("o.location = :location")->setParameter("location", $search->location);

        if ($search->status)
            $qb = $qb->andWhere("o.status = :status")->setParameter("status", $search->status);

        return $qb->getQuery()->getResult();
    }

    /**
     * This function searches in fields: Sku (of products) and orderNr (of orders)
     */
    public function findByBarcodeSearchQuery(\AppBundle\Helper\IndexSearchContainer $search)
    {
        $result = array();

        foreach ($this->findBySearchQuery($search) as $product)
        {
            /** @var Product $product */
            $result["product-".$product->getId()] = sprintf("Product '%s' with SKU %s, in quantity %s, at location %s",
                $product->getName(), $product->getSku(), $product->getQuantityInStock(true), $product->getLocation()->getName());
        }

        foreach ($this->_em->getRepository(\AppBundle\Entity\SalesOrder::class)->findBySearchQuery($search) as $salesOrder)
        {
            /** @var \AppBundle\Entity\SalesOrder $salesOrder */
            $result["salesorder-".$salesOrder->getId()] = sprintf("Sales order with nr %s, dated %s, to customer %s, at location %s",
                $salesOrder->getOrderNr(), $salesOrder->getOrderDate()->format("M j, Y"), $salesOrder->getCustomer()->getName(), $salesOrder->getLocation()->getName());
        }

        foreach ($this->_em->getRepository(\AppBundle\Entity\PurchaseOrder::class)->findBySearchQuery($search) as $purchaseOrder)
        {
            /** @var \AppBundle\Entity\PurchaseOrder $purchaseOrder */
            $result["purchaseorder-".$purchaseOrder->getId()] = sprintf("Purchase order with nr %s, dated %s, from supplier %s, at location %s",
                $purchaseOrder->getOrderNr(), $purchaseOrder->getOrderDate()->format("M j, Y"), $purchaseOrder->getSupplier()->getName(), $purchaseOrder->getLocation()->getName());
        }

        return $result;
    }

    public function findStock(User $user)
    {
        $products = $this->findMine($user);

        $products = array_filter($products,
            function(Product $product) {
                return $product->getQuantityInStock(true) != 0;
            });

        return $products;
    }

    public function findStockAndNotYetInOrder(User $user, SalesOrder $order)
    {
        $products = $this->findStock($user);

        // cannot add product to sales order twice
        $products = array_filter($products,
            function (Product $product) use ($order) {
                /** @var SalesOrder $order */
                foreach ($order->getProductRelations() as $r)
                {
                    if ($r->getProduct() == $product)
                        return false;
                }
                return true;
            });

        return $products;
    }

    public function generateProductAttributeRelations(Product $product)
    {
        // get all possible attributes for this product type
        $allAttributes = $product->getType()->getAttributes();

        // add new attributes to this product
        foreach ($allAttributes as $newAttribute)
        {
            $exists = $product->getAttributeRelations()->exists(function($key, $r) use ($newAttribute) {
                /** @var ProductAttributeRelation $r */
                return $r->getAttribute() == $newAttribute;
            });

            if (!$exists)
            {
                $r = new ProductAttributeRelation();
                $r->setAttribute($newAttribute);
                $r->setProduct($product);
                $this->_em->persist($r);
                $product->addAttributeRelation($r);
            }
        }
    }

    public function generateProductOrderRelation(Product $product, AOrder $order, $quantity = 1)
    {
        $exists = $product->getOrderRelations()->exists(function($key, $r) use ($order) {
            /** @var ProductOrderRelation $r */
            return $r->getOrder() == $order;
        });

        if (!$exists)
        {
            $r = new ProductOrderRelation();
            $r->setOrder($order);
            $r->setProduct($product);
            $r->setQuantity($quantity);
            $this->_em->persist($r);
            $product->addOrderRelation($r);
        }
    }
}
